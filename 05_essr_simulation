import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter

# --- Configuration Constants ---

CHRONOS_PRED_PATH = 'chronos_forecasts.pkl'
SIMULATION_RUNS = 1000  # Number of MCS trials
PREDICTION_LENGTH = 12

# Variables for prediction (components of energy supply and demand)
VARS_TO_SAMPLE = ['PV_gene(MJ)', 'FC_gene(MJ)', 'elect_cons(MJ)', 'gas_cons(MJ)']
# Quantile levels output by Chronos
QUANTILE_LEVELS = [0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90]

# Graph style settings
STYLE_CONFIG = {
    'forecast_mc': {'color': 'blue', 'label': 'Forecast (MCS)'},
    'actual': {'color': 'red', 'label': 'Actual'},
    'threshold': {'color': 'grey', 'linestyle': '--', 'label': 'ESSR 50% Threshold'}
}

# --- Dummy Data Loader (Required for main script execution) ---
# NOTE: This temporary function is necessary because the main script relies on 
# 'load_and_preprocess_data' and 'CSV_FILE_NAME' which were defined in a previous user input.
# EVAL_START_DATE and CSV_FILE_NAME are also defined here for the scope of this file.
EVAL_START_DATE = '2023-04'
EVAL_END_DATE = '2024-03'
CSV_FILE_NAME = 'sample_cleaned_data.csv'

def load_and_preprocess_data(file_name):
    """Temporary function to load actual data for comparison (Needs full implementation outside this file)."""
    try:
        df = pd.read_csv(file_name, parse_dates=['datetime'])
        df.set_index('datetime', inplace=True)
        # Simplified monthly aggregation and unit conversion for demo purposes
        df_monthly = df.groupby('ID').resample('MS').sum().reset_index(level='ID')
        df_monthly.columns = [col.replace('(kWh)', '(MJ)').replace('(m3)', '(MJ)') for col in df_monthly.columns]
        df_monthly.reset_index(names=['timestamp'], inplace=True)
        df_monthly['timestamp'] = df_monthly['timestamp'].dt.strftime('%Y-%m')
        return df_monthly
    except FileNotFoundError:
        return pd.DataFrame()


# --------------------------------------------------------------------------------
# --- 1. Data Loading and Preparation for MCS ---
# --------------------------------------------------------------------------------

def load_and_prepare_for_mcs(chronos_path):
    """Loads Chronos forecast results and reshapes the data for MCS sampling."""
    
    print(f"--- 1. Loading Chronos Forecast Results: {chronos_path} ---")
    try:
        df_pred = pd.read_pickle(chronos_path)
    except FileNotFoundError:
        raise FileNotFoundError(f"Error: {chronos_path} not found.")

    # Create data structure for MCS sampling
    # Objective: Get a list of quantiles for each variable, per household (ID) and per month (timestamp).
    
    # Get unique combinations of [ID, timestamp]
    unique_time_series = df_pred[['ID', 'timestamp']].drop_duplicates()
    
    # Dictionary to store results
    sampling_data = {}
    
    for _, row in unique_time_series.iterrows():
        h_id = row['ID']
        month = row['timestamp']
        
        # Extract the quantile data row for the corresponding household and month
        row_data = df_pred[(df_pred['ID'] == h_id) & (df_pred['timestamp'] == month)].iloc[0]
        
        # Create sampling quantile data per variable
        month_samples = {}
        for var in VARS_TO_SAMPLE:
            # Extract q10, q20, ..., q90 values for the variable
            quantile_values = [row_data[f'{var}_chronos_q{int(q * 100):02d}'] for q in QUANTILE_LEVELS]
            month_samples[var] = np.array(quantile_values)
        
        if h_id not in sampling_data:
            sampling_data[h_id] = {}
        sampling_data[h_id][month] = month_samples
        
    print(f"✅ MCS sampling data preparation complete (Total {len(sampling_data)} households).")
    return sampling_data

# --------------------------------------------------------------------------------
# --- 2. Monte Carlo Simulation Execution ---
# --------------------------------------------------------------------------------

def run_monte_carlo_simulation(sampling_data, n_runs):
    """
    Executes Monte Carlo simulation based on Chronos quantile forecasts 
    to derive the probability distribution of ESSR.
    
    Args:
        sampling_data (dict): Quantile data prepared in Step 1 for sampling
        n_runs (int): Number of MCS trials
        
    Returns:
        dict: ESSR simulation results per household (ESSR array of size [n_runs])
    """
    
    print(f"\n--- 2. Executing Monte Carlo Simulation (N={n_runs}) ---")
    
    all_household_essr_runs = {}
    
    # Probability points for sampling quantiles from the CDF
    # Since QUANTILE_LEVELS are [0.10, 0.20, ..., 0.90],
    # probability 0.00-0.10 uses q10, 0.10-0.20 uses q20, etc.
    q_points = np.array(QUANTILE_LEVELS)
    
    # Reviewer Comment on Correlation Assumption:
    print("\nWARNING: For simplification, this simulation assumes that the components of ESSR,")
    print("         i.e., PV, FC, Elec Cons, and Gas Cons sampled from their respective")
    print("         forecast distributions, are **mutually independent**.")
    print("         (A true model should account for existing correlations, especially between Elec Cons and Gas Cons.)\n")

    
    for h_id, monthly_data in sampling_data.items():
        
        annual_essr_simulations = np.zeros(n_runs)
        
        for run in range(n_runs):
            total_pv_fc_supply = 0.0
            total_elect_gas_demand = 0.0
            
            # --- 1. Sampling for each month ---
            # Sampling is performed for each month of the prediction period (12 months)
            for month_key, month_samples in monthly_data.items():
                
                # Generate a uniform random number (0-1) to determine which quantile level to use
                random_p = np.random.rand()  
                
                # Identify the index of the corresponding quantile level (e.g., 0.10 -> idx 0)
                # np.searchsorted: returns the insertion point for random_p
                # Example: q_points=[0.1, 0.2, ...], random_p=0.05 -> idx=0
                q_index = np.searchsorted(q_points, random_p, side='right')
                
                # Clip the index to be within the range 0-8 (corresponding to q10 through q90)
                q_index = np.clip(q_index, 0, len(QUANTILE_LEVELS) - 1)
                
                # --- 2. Retrieve the quantile values ---
                
                # PV and FC are on the supply side
                pv_value = month_samples['PV_gene(MJ)'][q_index]
                fc_value = month_samples['FC_gene(MJ)'][q_index]
                
                # Electricity and gas consumption are on the demand side
                elect_cons_value = month_samples['elect_cons(MJ)'][q_index]
                gas_cons_value = month_samples['gas_cons(MJ)'][q_index]
                
                # --- 3. Accumulate to annual totals ---
                total_pv_fc_supply += pv_value + fc_value
                total_elect_gas_demand += elect_cons_value + gas_cons_value
            
            # --- 4. Calculate Annual ESSR ---
            if total_elect_gas_demand > 0:
                annual_essr_simulations[run] = total_pv_fc_supply / total_elect_gas_demand
            else:
                annual_essr_simulations[run] = 0.0 # ESSR is zero if demand is zero

        all_household_essr_runs[h_id] = annual_essr_simulations
        
    print("✅ ESSR simulation completed for all households.")
    return all_household_essr_runs

# --------------------------------------------------------------------------------
# --- 3. Result Aggregation and Visualization ---
# --------------------------------------------------------------------------------

def summarize_and_visualize(essr_sim_results, true_data):
    """
    Aggregates MCS results and plots the Cumulative Distribution Function (CDF) of ESSR.
    
    Args:
        essr_sim_results (dict): ESSR simulation results from MCS
        true_data (pd.DataFrame): Actual values for the evaluation period
    """
    
    print("\n--- 3. Aggregation and Visualization ---")
    
    # --- A. Aggregation of Simulation Results (Mean ESSR and Achievement Probability) ---
    essr_summary = []
    
    for h_id, essr_runs in essr_sim_results.items():
        
        # Calculate statistics
        mean_essr = np.mean(essr_runs)
        median_essr = np.median(essr_runs)
        std_essr = np.std(essr_runs)
        
        # Calculate probability of achieving ESSR >= 50%
        prob_50_percent = np.mean(essr_runs >= 0.5)
        
        # Calculate Actual ESSR (Requires actual data)
        actual_data = true_data[true_data['ID'] == h_id]
        if not actual_data.empty:
            actual_supply = actual_data['PV_gene(MJ)'].sum() + actual_data['FC_gene(MJ)'].sum()
            actual_demand = actual_data['elect_cons(MJ)'].sum() + actual_data['gas_cons(MJ)'].sum()
            actual_essr = actual_supply / actual_demand if actual_demand > 0 else 0.0
        else:
            actual_essr = np.nan
        
        essr_summary.append({
            'ID': h_id,
            'Actual ESSR': actual_essr,
            'Forecast Mean ESSR': mean_essr,
            'Prob(ESSR >= 50%)': prob_50_percent,
            'ESSR Std Dev': std_essr,
            'ESSR 10th Percentile': np.percentile(essr_runs, 10)
        })
        
    df_essr_summary = pd.DataFrame(essr_summary).set_index('ID')
    
    print("\n--- ESSR Simulation Summary (Per Household) ---")
    display(df_essr_summary.head())
    
    # --- B. Plotting the ESSR Distribution for All Households (CDF) ---
    
    # 1. Flatten all simulation results (All households combined)
    all_runs_flat = np.concatenate(list(essr_sim_results.values()))
    
    # 2. Actual ESSR for all households (for CDF comparison)
    # Calculate annual ESSR per household to get the distribution of these values
    df_true_annual_summary = true_data.groupby('ID').agg({
        'PV_gene(MJ)': 'sum', 'FC_gene(MJ)': 'sum',
        'elect_cons(MJ)': 'sum', 'gas_cons(MJ)': 'sum'
    })
    df_true_annual_summary['Actual_ESSR'] = (
        df_true_annual_summary['PV_gene(MJ)'] + df_true_annual_summary['FC_gene(MJ)']
    ) / (
        df_true_annual_summary['elect_cons(MJ)'] + df_true_annual_summary['gas_cons(MJ)']
    )
    all_actual_essr = df_true_annual_summary['Actual_ESSR'].values
    
    # Plotting the CDF 
    PERCENT_FORMATTER = PercentFormatter(xmax=1, decimals=0)
    
    plt.figure(figsize=(8, 6))
    
    # Predicted ESSR CDF
    sns.ecdfplot(all_runs_flat, color=STYLE_CONFIG['forecast_mc']['color'], 
                 linestyle='-', linewidth=2, label=STYLE_CONFIG['forecast_mc']['label'], alpha=0.8)
    
    # Actual ESSR CDF (This will be a step function based on the number of households N)
    sns.ecdfplot(all_actual_essr, color=STYLE_CONFIG['actual']['color'], 
                 linestyle='--', linewidth=2, label=STYLE_CONFIG['actual']['label'], alpha=0.8)

    # Graph decoration (English)
    plt.xlabel('Annual Energy Self-Sufficiency Ratio (ESSR)', fontsize=12)
    plt.ylabel('Cumulative Share of Households', fontsize=12)
    
    # ZEH/ESSR 50% Threshold
    plt.axvline(0.5, color=STYLE_CONFIG['threshold']['color'], linestyle='--', linewidth=1, label='ESSR 50%')
    
    # Format axes as percentages
    plt.gca().xaxis.set_major_formatter(PERCENT_FORMATTER)
    plt.gca().yaxis.set_major_formatter(PERCENT_FORMATTER)
    plt.xlim(0, 1.0); plt.ylim(0, 1.01)
    
    plt.legend(loc='best')
    plt.title('CDF of Annual ESSR (Forecast vs. Actual) for All Households', fontsize=14)
    plt.show()
    
    # --- C. Saving Results ---
    df_essr_summary.to_pickle("essr_simulation_summary.pkl")
    print("\n✅ ESSR simulation results saved to 'essr_simulation_summary.pkl'.")

# --------------------------------------------------------------------------------
# --- Main Process ---
# --------------------------------------------------------------------------------

if __name__ == '__main__':
    try:
        # Prepare MCS sampling data
        sampling_data = load_and_prepare_for_mcs(CHRONOS_PRED_PATH)
        
        # Execute MCS
        essr_sim_results = run_monte_carlo_simulation(sampling_data, SIMULATION_RUNS)
        
        # Load actual data again for ESSR comparison
        temp_df = load_and_preprocess_data(CSV_FILE_NAME)
        df_true_eval = temp_df[
            (temp_df['timestamp'] >= EVAL_START_DATE) & (temp_df['timestamp'] <= EVAL_END_DATE)
        ].copy()
        
        # Aggregate and visualize
        summarize_and_visualize(essr_sim_results, df_true_eval)
        
        print("\n=== ESSR Simulation and Error Check Completed. ===")
        
    except FileNotFoundError as e:
        print(f"\nFatal Error occurred: {e}")
        print("Please verify that the Chronos prediction results file exists.")
    except Exception as e:
        print(f"\nFatal Error occurred: {e}")
        print("=== Error occurred during ESSR Simulation execution. ===")
